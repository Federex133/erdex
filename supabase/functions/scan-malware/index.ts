
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { fileName, fileData, fileSize, fileType } = await req.json()

    console.log(`Iniciando escaneo de malware para archivo: ${fileName}`)

    // Obtener la API key de VirusTotal desde los secrets
    const virusTotalApiKey = Deno.env.get('VIRUSTOTAL_API_KEY')
    
    if (!virusTotalApiKey) {
      console.error('VirusTotal API key no encontrada')
      return new Response(
        JSON.stringify({
          is_safe: true, // Permitir archivo si no hay API key
          scan_id: `no_api_key_${Date.now()}`,
          threat_detected: false,
          scan_date: new Date().toISOString(),
          details: { message: 'API key no configurada - archivo aprobado por defecto' }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Decodificar el archivo base64
    const fileBytes = Uint8Array.from(atob(fileData), c => c.charCodeAt(0))
    
    // Crear FormData para VirusTotal
    const formData = new FormData()
    const blob = new Blob([fileBytes], { type: fileType })
    formData.append('file', blob, fileName)

    console.log(`Enviando archivo a VirusTotal: ${fileName} (${fileSize} bytes)`)

    // Subir archivo a VirusTotal para escaneo (API v2)
    const uploadResponse = await fetch('https://www.virustotal.com/vtapi/v2/file/scan', {
      method: 'POST',
      headers: {
        'apikey': virusTotalApiKey,
      },
      body: formData
    })

    if (!uploadResponse.ok) {
      console.error(`VirusTotal upload failed: ${uploadResponse.status}`)
      throw new Error(`VirusTotal upload failed: ${uploadResponse.status}`)
    }

    const uploadResult = await uploadResponse.json()
    console.log('Respuesta de VirusTotal upload:', uploadResult)

    // Si el archivo ya fue escaneado previamente, obtener el resultado inmediatamente
    let reportResult = null
    let attempts = 0
    const maxAttempts = 10

    do {
      // Esperar antes de verificar el resultado (excepto en el primer intento)
      if (attempts > 0) {
        await new Promise(resolve => setTimeout(resolve, 3000))
      }

      // Obtener el resultado del escaneo
      const reportResponse = await fetch(`https://www.virustotal.com/vtapi/v2/file/report?apikey=${virusTotalApiKey}&resource=${uploadResult.resource}`)
      
      if (!reportResponse.ok) {
        console.error(`VirusTotal report failed: ${reportResponse.status}`)
        throw new Error(`VirusTotal report failed: ${reportResponse.status}`)
      }

      reportResult = await reportResponse.json()
      console.log(`Intento ${attempts + 1} - Resultado del reporte:`, reportResult)

      // Si response_code es 1, el escaneo está completo
      if (reportResult.response_code === 1) {
        console.log('Escaneo completado exitosamente')
        break
      }

      // Si response_code es 0, el archivo aún se está procesando
      if (reportResult.response_code === 0) {
        console.log('Archivo aún siendo procesado, esperando...')
        attempts++
        continue
      }

      // Si response_code es -2, el archivo está en cola
      if (reportResult.response_code === -2) {
        console.log('Archivo en cola de procesamiento, esperando...')
        attempts++
        continue
      }

      // Otros códigos de error
      console.error('Código de respuesta inesperado:', reportResult.response_code)
      break

    } while (attempts < maxAttempts)

    // Si no pudimos obtener el resultado después de varios intentos
    if (!reportResult || reportResult.response_code !== 1) {
      console.error('No se pudo obtener el resultado del escaneo después de varios intentos')
      return new Response(
        JSON.stringify({
          is_safe: true, // Marcar como seguro en caso de timeout
          scan_id: uploadResult.scan_id || `timeout_${Date.now()}`,
          threat_detected: false,
          scan_date: new Date().toISOString(),
          details: { 
            message: 'Timeout en escaneo - archivo aprobado por defecto',
            response_code: reportResult?.response_code || 'unknown'
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Analizar los resultados con lógica más conservadora
    const positives = reportResult.positives || 0
    const total = reportResult.total || 0
    
    // NUEVA LÓGICA MÁS CONSERVADORA:
    // Solo marcar como virus si:
    // 1. Hay al menos 3 detecciones positivas Y
    // 2. Más del 10% de los antivirus lo detectan
    const minDetections = 3
    const minPercentage = 0.1 // 10%
    
    const threatDetected = positives >= minDetections && (positives / total) >= minPercentage

    console.log(`Análisis: ${positives}/${total} detecciones (${((positives/total)*100).toFixed(1)}%)`)
    console.log(`Umbral: mín ${minDetections} detecciones Y ≥${(minPercentage*100)}% de ratio`)
    console.log(`Resultado: Threat detected = ${threatDetected}`)

    // Filtrar motores que detectaron el archivo para información
    const detectedEngines = reportResult.scans ? 
      Object.entries(reportResult.scans)
        .filter(([_, scan]: [string, any]) => scan.detected)
        .map(([engine, scan]: [string, any]) => ({
          engine,
          result: scan.result
        })) : []

    const scanResult = {
      is_safe: !threatDetected,
      scan_id: uploadResult.scan_id,
      threat_detected: threatDetected,
      scan_date: new Date().toISOString(),
      details: {
        positives: positives,
        total: total,
        percentage: ((positives/total)*100).toFixed(1),
        scan_date: reportResult.scan_date,
        permalink: reportResult.permalink,
        detected_engines: detectedEngines,
        scans: detectedEngines.map(e => e.engine)
      }
    }

    console.log(`Resultado final del escaneo para ${fileName}:`, scanResult)

    return new Response(
      JSON.stringify(scanResult),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Error en scan-malware function:', error)
    
    // En caso de error, marcar como seguro para evitar bloquear archivos legítimos
    return new Response(
      JSON.stringify({
        is_safe: true,
        scan_id: `error_${Date.now()}`,
        threat_detected: false,
        scan_date: new Date().toISOString(),
        details: { 
          error: error.message, 
          message: 'Error en comunicación - archivo aprobado por defecto' 
        }
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
